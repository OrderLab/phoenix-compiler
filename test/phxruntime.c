#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include <time.h>
#include <string.h>

#include <err.h>

#define IN_PHX_RUNTIME
#include "../include/phx_instrument_compiler_abi.h"
#include "../include/phx_instrument.h"

#define PHX_AUTO_UNSAFE_ABI 104
#define __phx_storage_limit 1024

#define safe false
#define unsafe true

/* ====================== Unexported Compiler ABI ===================== */

/* Local state definition
 *
 * when checking: should assert that F/LCALL xor (i == top)
 *
 * flcallee_done is reset to false in caller when F/LCALL is about to run
 * flcallee_done is ignored if caller not in F/LCALL state, since callee will
 * always modify this state
 */
struct __phx_func_state {
    /* Function id used for relation lookup */
    func_id_t func_id;
    /* Unified state.
     * Contains narg + 2 elements:
     *   flcallee_done: [0]
     *   arg_state: [1-] where
     *     [1]: no argument tracked scenario
     *     [2+index]: index argument tracked scenario
     */
    uint8_t __unified_states[];
};

/* ================== Thread-local and global storage ================== */

/* Base is the sentinel. */
static struct __phx_func_state __phx_func_state_base = { INT_MAX };

/* Per-thread storage. This is unexported and not used by the compiler.
 * Future: use NON-readable boundary page after the array to catch overflow. */
thdlocal static volatile
struct __phx_func_state *__phx_func_state_storage_tls[__phx_storage_limit] = { &__phx_func_state_base };

/* Per-thread top pointer. This is visible to the compiler.
 * top is the pointer for the current call layer */
thdlocal volatile
struct __phx_func_state **__phx_func_state_top_tls;  // = RUNTIME __phx_func_state_storage_tls;
// TODO: optimize storage access by using limited arg state

// TODO: change to use standard linked list header
struct list {
    struct list *prev;
    struct list *next;
};

struct phx_trace {
    struct list node;
    const volatile struct __phx_func_state **base;
    const volatile struct __phx_func_state ***top;
};

/* Per-thread trace. */
thdlocal static
struct phx_trace phx_trace_tls /* = RUNTIME INITIALIZER */;

/* Global list of all traces. */
static pthread_mutex_t __phx_traces_lock = PTHREAD_MUTEX_INITIALIZER;
static struct list __phx_traces = { &__phx_traces, &__phx_traces, };

/* ======================= Generated by compiler ======================= */

#define PHX_INJECT_TESTING
#ifdef PHX_INJECT_TESTING
/* Mode variable read by the generated stub function. */
__attribute__((weak)) volatile int __phx_inject_run_mode = 0;
#endif

extern const uint32_t __phx_auto_unsafe_abi;

extern const func_id_t __phx_nfunc;
extern const struct __phx_func_relation *__phx_func_relations[];

extern const uint32_t __phx_nroots;
extern const struct __phx_root_info __phx_func_roots[];

// ABI version 0 means no auto unsafe region support
__attribute__((weak)) const uint32_t __phx_auto_unsafe_abi = 0;

__attribute__((weak)) const func_id_t __phx_nfunc = 0;
__attribute__((weak)) const struct __phx_func_relation *__phx_func_relations[0];

__attribute__((weak)) const uint32_t __phx_nroots = 0;
__attribute__((weak)) const struct __phx_root_info __phx_func_roots[0];

/* ======================= Forward declarations ======================= */

struct func_arg {
    void *(*start_routine)(void *);
    void *arg;
};

static void phx_debug_unsafe_range_one(
    const volatile struct __phx_func_state **base,
    const volatile struct __phx_func_state **top);

static bool phx_auto_is_unsafe_one(
    const volatile struct __phx_func_state **base,
    const volatile struct __phx_func_state **top);

static void *__phx_thread_wrapper(void *arg);

/* ============================ Public APIs ============================ */

bool phx_has_auto_unsafe(void) {
    return __phx_auto_unsafe_abi == PHX_AUTO_UNSAFE_ABI;
}

void phx_debug_unsafe_range(void) {
    size_t trace_id = 0;

    fprintf(stderr, "__phx_auto_unsafe_abi = %d\n", __phx_auto_unsafe_abi);
#ifdef PHX_INJECT_TESTING
    fprintf(stderr, "__phx_inject_run_mode = %d\n", __phx_inject_run_mode);
#endif
    if (__phx_auto_unsafe_abi == 0) {
        fprintf(stderr, "PHX auto unsafe region not supported, skipping debug.\n");
        return;
    } else if (__phx_auto_unsafe_abi != PHX_AUTO_UNSAFE_ABI) {
        fprintf(stderr, "PHX auto unsafe ABI does not match. Supported: %u. Found: %u.\n",
            PHX_AUTO_UNSAFE_ABI, __phx_auto_unsafe_abi);
        return;
    }

    fprintf(stderr, "__phx_nroots = %u\n", __phx_nroots);
    for (size_t i = 0; i < __phx_nroots; ++i) {
        const struct __phx_root_info *root = &__phx_func_roots[i];
        fprintf(stderr, "__phx_func_roots[%lu] = { %u, %u }\n", i, root->func_id, root->initial_arg);
    }

    fprintf(stderr, "===== Iterating phoenix traces =====\n");

    // This is only used to avoid list changes, but does not avoid races of phx
    // trace. That race is considered fine here.
    struct timespec ts = { .tv_sec = 0, .tv_nsec = 100000000 }; // 100ms
    if (pthread_mutex_timedlock(&__phx_traces_lock, &ts)) {
        fprintf(stderr, "Cannot grab phx_traces_lock in 100ms, skipping debug.\n");
        goto out;
    }

    for (struct list *node = __phx_traces.next; node != &__phx_traces; node = node->next) {
        struct phx_trace *trace = (struct phx_trace *)node; // to use container_of

        fprintf(stderr, "Trace #%ld:\n", trace_id++);
        phx_debug_unsafe_range_one(trace->base, *trace->top);
    }

    pthread_mutex_unlock(&__phx_traces_lock);
out:
    fprintf(stderr, "===== End iterating phoenix traces =====\n");
}

bool phx_auto_is_unsafe(void) {
    size_t trace_id = 0;

    if (__phx_auto_unsafe_abi == 0) {
        errx(EXIT_FAILURE, "phx_auto_is_unsafe: auto unsafe region not supported. Aborting.");
    } else if (__phx_auto_unsafe_abi != PHX_AUTO_UNSAFE_ABI) {
        errx(EXIT_FAILURE, "PHX auto unsafe ABI does not match. Aborting. Supported: %u. Found: %u.\n",
            PHX_AUTO_UNSAFE_ABI, __phx_auto_unsafe_abi);
    }

    // This is only used to avoid list changes, but does not avoid races of phx
    // trace. That race is considered fine here.
    struct timespec ts = { .tv_sec = 3, .tv_nsec = 100000000 }; // 100ms
    if (pthread_mutex_timedlock(&__phx_traces_lock, &ts)) {
        fprintf(stderr, "phx_auto_is_unsafe cannot grab phx_traces_lock in 100ms, returning unsafe.\n");
        return unsafe;
    }

    if (__phx_traces.next == &__phx_traces) {
        pthread_mutex_unlock(&__phx_traces_lock);
        errx(EXIT_FAILURE, "phx_auto_is_unsafe: ASSERT no traces, incorrect setup!");
    }

    for (struct list *node = __phx_traces.next; node != &__phx_traces; node = node->next) {
        struct phx_trace *trace = (struct phx_trace *)node; // to use container_of

        fprintf(stderr, "Analyzing trace #%ld:\n", trace_id++);
        if (phx_auto_is_unsafe_one(trace->base, *trace->top)) {
            pthread_mutex_unlock(&__phx_traces_lock);
            return unsafe;
        }
    }

    pthread_mutex_unlock(&__phx_traces_lock);

    return safe;
}

void __phx_instrument_init_thread(void) {
    // fprintf(stderr, "phx_instrument_init_thread\n");

    pthread_mutex_lock(&__phx_traces_lock);

    __phx_func_state_top_tls = __phx_func_state_storage_tls;

    phx_trace_tls.base = (const volatile struct __phx_func_state **)__phx_func_state_storage_tls;
    phx_trace_tls.top = (const volatile struct __phx_func_state ***)&__phx_func_state_top_tls;

    /* insert tail */
    phx_trace_tls.node.prev = __phx_traces.prev;
    phx_trace_tls.node.next = &__phx_traces;
    __phx_traces.prev->next = &phx_trace_tls.node;
    __phx_traces.prev = &phx_trace_tls.node;

    pthread_mutex_unlock(&__phx_traces_lock);
}

void __phx_instrument_thread_cleanup(void *arg) {
    // fprintf(stderr, "phx_instrument_thread_cleanup\n");

    (void)arg;
    pthread_mutex_lock(&__phx_traces_lock);

    phx_trace_tls.node.prev->next = phx_trace_tls.node.next;
    phx_trace_tls.node.next->prev = phx_trace_tls.node.prev;

    // reset
    phx_trace_tls.node.prev = phx_trace_tls.node.next = &phx_trace_tls.node;

    pthread_mutex_unlock(&__phx_traces_lock);
}

int phx_pthread_create_wrapper(pthread_t *thread, const pthread_attr_t *attr,
    void *(*start_routine)(void *), void *arg)
{
   struct func_arg *pa = (struct func_arg *)malloc(sizeof(*pa));
   pa->start_routine = start_routine;
   pa->arg = arg;
   return pthread_create(thread, attr, __phx_thread_wrapper, pa);
}


/* =========================== Internal APIs =========================== */

/*
// bisec
struct func_relations *__phx_get_func_relation(size_t func_id) {
    size_t l = 0, r = __phx_nfunc;
    while (l < r) {
        size_t mid = (l + r) / 2;
        uint32_t midid = __phx_func_relations[mid]->func_id;
        if (midid == func_id)
            return __phx_func_relations + mid;
        else if (midid < func_id)
            l = mid + 1;
        else // midid > func_id
            r = mid;
    }
}
*/

static const struct __phx_root_info *phx_find_root_func(func_id_t func_id) {
    /* Binary search for func_id in sorted __phx_func_roots array */
    uint32_t left = 0;
    uint32_t right = __phx_nroots;

    while (left < right) {
        uint32_t mid = left + (right - left) / 2;
        if (__phx_func_roots[mid].func_id == func_id) {
            return &__phx_func_roots[mid];
        }
        if (__phx_func_roots[mid].func_id < func_id) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    return NULL;
}

static bool phx_is_root_func(func_id_t func_id) {
    return phx_find_root_func(func_id) != NULL;
}

static void phx_debug_unsafe_range_one(
    const volatile struct __phx_func_state **base,
    const volatile struct __phx_func_state **top)
{
    const size_t height = top - base;
    fprintf(stderr, "phx state height = %lu\n", height);

    fprintf(stderr, "__phx_func_state_array[] = {\n");
    for (size_t start = 1; start <= height; ++start) {
        fprintf(stderr, "    [%lu] = {", start);

        func_id_t func_id = base[start]->func_id;
        fprintf(stderr, " %u", func_id);
        if (func_id >= __phx_nfunc) {
            fprintf(stderr, "\nError: PHX unsafe instrument stack likely corrupted! Aborting...\n");
            exit(1);
        }

        const struct __phx_func_relation *f = __phx_func_relations[func_id];

        fprintf(stderr, " %s%s, [", f->func_name, phx_is_root_func(func_id) ? " (root)" : "");

        fprintf(stderr, "callee returned: 0x%hhx | empty: 0x%hhx | ",
            base[start]->__unified_states[0],
            base[start]->__unified_states[1]
        );
        for (size_t j = 2; j <= f->nargs + 1; ++j) {
            fprintf(stderr, "%lu: 0x%hhx, ", j-1, base[start]->__unified_states[j]);
        }
        fprintf(stderr, "] },\n");
    }
    fprintf(stderr, "}\n");
}

static uint8_t phx_get_modify_type(func_id_t func_id, uint8_t caller_arg) {
    if (func_id >= __phx_nfunc) {
        fprintf(stderr, "Bug: func_id %u >= __phx_nfunc %u, aborting!\n", func_id, __phx_nfunc);
        exit(1);
    }
    const struct __phx_func_relation *func_info = __phx_func_relations[func_id];
    // caller_arg is in [0, nargs]. 0 reserved for global
    if (caller_arg > func_info->nargs) {
        fprintf(stderr, "Bug: caller_arg %u > nargs %u, aborting!\n", caller_arg, func_info->nargs);
        exit(1);
    }

    return func_info->modify_type[caller_arg];
}

static uint8_t phx_get_relation_argtaint(func_id_t func_id, uint8_t caller_arg, uint8_t callsite) {
    if (func_id >= __phx_nfunc) {
        fprintf(stderr, "Bug: func_id %u >= __phx_nfunc %u, aborting!\n", func_id, __phx_nfunc);
        exit(1);
    }

    const struct __phx_func_relation *func_info = __phx_func_relations[func_id];
    uint32_t count = func_info->nrelations;
    for (const struct __phx_taint_pair *it = func_info->taints; count--; ++it) {
        if (it->callsite == callsite && it->caller_arg == caller_arg) {
            // FIXME: we should actually check the bitmap
            if (it->argtaint == 0) {
                fprintf(stderr, "Bug: taint bitmap is empty for func %u at callsite %u\n", func_id, callsite);
                exit(1);
            }
            for (ArgBitmap i = 0; i < 32; ++i) {
                if (it->argtaint & (1 << i)) {
                    return i;
                }
            }
            fprintf(stderr, "Bug: taint bitmap is empty for func %u at callsite %u\n", func_id, callsite);
            exit(1);
        }
    }
    fprintf(stderr, "Cannot find taint info for func %u at callsite %u\n", func_id, callsite);
    exit(1);
}

// TODO: turn this into an inline function
#define arg_state(start) ((*(start))->__unified_states + 1)
#define callee_returned(start) ((*(start))->__unified_states[0])
#define bad_state(state) do { \
        fprintf(stderr, "Bug: Bad "#state" %d, aborting!\n", state); \
        exit(1); \
    } while (0)

static bool phx_descend_find_may_modify_external_safe(
    const volatile struct __phx_func_state **start,
    const volatile struct __phx_func_state **top,
    uint8_t start_arg)
{
    for (; start <= top; ++start) {
        uint8_t start_state = arg_state(start)[start_arg];
        uint8_t modify_type = phx_get_modify_type((*start)->func_id, start_arg);

        switch (modify_type) {
        case NO_MODIFY: continue;
        case MAY_MODIFY_EXTERNAL_SAFE: return unsafe;
        case MAY_MODIFY: continue; // FIXME: check whether this is forced safe
        default: bad_state(modify_type);
        }

        start_arg = phx_get_relation_argtaint((*start)->func_id, start_arg, start_state);
    }
    return safe;
}

#if 1

/*
 * Determine if the whole system is in a safe state.
 *
 * The basic idea is that all layers should be either on or to the left of
 * FCALL, or on or to the right of LCALL.
 *
 * This is the runtime API to use in signal handler.
 */
static bool phx_auto_is_unsafe_one(
    const volatile struct __phx_func_state **base,
    const volatile struct __phx_func_state **top)
{

#if 0
#define trace(fmt, ...) do { } while (0)
#else
#define trace(fmt, ...) do { fprintf(stderr, "phx trace: " fmt,  ##__VA_ARGS__); } while (0)
#endif

    const volatile struct __phx_func_state **start = base + 1;
    /*
     * Find the first root function call. If not found, it's safe.
     */
    while (start <= top && !phx_is_root_func((*start)->func_id)) {
        trace("before start: %lu, func_id %u, is root %d\n",
                start - base,
                (*start)->func_id, phx_is_root_func((*start)->func_id));
        ++start;
    }
    if (start > top)
        return safe;

    trace("found start: %lu\n", start - base);

    /*
     * Determine the overall expect state: find the first layer of not FLCALL.
     *
     * FIXME: handle multi-callee taint scenario
     * In that case, all arg scenario need to be all(max(state) <= FCALL), or
     * all(min(state) >= LCALL)
     */
    uint8_t expect_state = __STATE_END;
    uint8_t start_arg = phx_find_root_func((*start)->func_id)->initial_arg;
    if (start_arg == 0) {
        fprintf(stderr, "Bug: root function has RESERVED arg, aborting!\n");
        exit(1);
    }

    for (; start <= top; ++start) {

        uint8_t start_state = arg_state(start)[start_arg];
        uint8_t modify_type = phx_get_modify_type((*start)->func_id, start_arg);

        trace("start_arg = %u, start_state = %u, modify_type = %u\n",
                start_arg, start_state, modify_type);

        switch (modify_type) {
        case NO_MODIFY: return phx_descend_find_may_modify_external_safe(start, top, start_arg);
        case MAY_MODIFY_EXTERNAL_SAFE: return unsafe;
        case MAY_MODIFY: break;  // Expected state.
        default: bad_state(modify_type);
        }

        switch (start_state) {
        case MODIFYING:     return unsafe;

        case UNMODIFIED:
        case MODIFY_END:    return phx_descend_find_may_modify_external_safe(start, top, start_arg);

        case FCALL:
            if (start == top)
                return callee_returned(start) ? unsafe : safe;
            expect_state = FCALL;   // <= FCALL
            break;
        case LCALL:
            if (start == top)
                return callee_returned(start) ? safe : unsafe;
            expect_state = LCALL;   // >= LCALL
            break;
        case FLCALL:
            if (start == top)
                return safe;
            break;
        default: bad_state(start_state);
        }

        if (expect_state != __STATE_END)
            break;

        start_arg = phx_get_relation_argtaint((*start)->func_id, start_arg, start_state);
    }

    trace("expect_state = %u\n", expect_state);

    // There will a case where the last inspected `start` above is the same as
    // the first inspected `start` below, but that's fine.  Adding three
    // variables into the loop condition above will turn the it into spaghetti.

    /*
     * Iterate through all layers, all remaining layers should be the same
     *
     * FIXME (same): handle multi-callee taint scenario
     */
    for (; start <= top; ++start) {

        uint8_t start_state = arg_state(start)[start_arg];
        uint8_t modify_type = phx_get_modify_type((*start)->func_id, start_arg);

        trace("start_arg = %u, start_state = %u, modify_type = %u\n",
                start_arg, start_state, modify_type);

        switch (modify_type) {
        case NO_MODIFY: return phx_descend_find_may_modify_external_safe(start, top, start_arg);
        case MAY_MODIFY_EXTERNAL_SAFE: return unsafe;
        case MAY_MODIFY: break;  // Expected state.
        default: bad_state(modify_type);
        }

        if (expect_state == FCALL) {
            switch (start_state) {
            // left, safe
            case UNMODIFIED:    return phx_descend_find_may_modify_external_safe(start, top, start_arg);
            // mid or right, unsafe
            case MODIFYING:
            case LCALL:
            case MODIFY_END:    return unsafe;
            // goto next layer
            case FCALL:
            case FLCALL:
                if (start == top)
                    return callee_returned(start) ? unsafe : safe;
                break;
            default: bad_state(start_state);
            }
        } else if (expect_state == LCALL) {
            switch (start_state) {
            // mid or left, unsafe
            case UNMODIFIED:
            case MODIFYING:
            case FCALL:         return unsafe;
            // right, safe
            case MODIFY_END:    return phx_descend_find_may_modify_external_safe(start, top, start_arg);
            // goto next layer
            case LCALL:
            case FLCALL:
                if (start == top)
                    return callee_returned(start) ? safe : unsafe;
                break;
            default: bad_state(start_state);
            }
        } else {
            bad_state(expect_state);
        }

        start_arg = phx_get_relation_argtaint((*start)->func_id, start_arg, start_state);
    }

    errx(EXIT_FAILURE, "Bug: should be unreachable, aborting!");

    #undef safe
    #undef unsafe
}

#else
/*
 * TODO: apply this version!
 *
 * Below is an unfinished draft that handles multi call site to the same
 * callee.
 */
bool phx_auto_is_unsafe(void) {
#define safe false
#define unsafe true

    size_t start;
    for (start = 0; start < __phx_func_state_top; ++start) {
        if (__phx_func_state_storage[start]->func_id == __phx_func_root)
            break;
    }
    if (start == __phx_func_state_top)
        return safe;

    const uint8_t start_state = __phx_func_state_storage[start]->arg_state[0];
    uint8_t expect_state;
    switch (start_state) {
    case MODIFYING: return unsafe;
    case UNMODIFIED:
    case MODIFY_END: return safe;

    case FCALL_BEGIN ... FCALL_END:
        expect_state = FCALL_BEGIN;
        break;
    case LCALL_BEGIN ... LCALL_END:
        expect_state = LCALL_BEGIN;
        break;
    default:
        errx(EXIT_FAILURE, "Unknown start state %d, aborting!", start_state);
    }
    int start_arg = phx_get_relation_argtaint(__phx_func_state_storage[start]->func_id, 0, start_state);

    for (size_t cur = start; cur < __phx_func_state_top; ++cur) {
        struct __phx_func_state *cur_layer = (struct __phx_func_state *)__phx_func_state_storage[cur];
        uint8_t cur_state = cur_layer->arg_state[start_arg];

        switch (cur_state) {
        case MODIFYING: return unsafe;
        case UNMODIFIED:
            return expect_state == FCALL_BEGIN;
        case MODIFY_END:
            return expect_state == LCALL_BEGIN;
        case FCALL_BEGIN ... FCALL_END:
            if (expect_state == LCALL_BEGIN)
                return unsafe;
            break;  // next iter
        case LCALL_BEGIN ... LCALL_END:
            if (expect_state == FCALL_BEGIN)
                return unsafe;
            break;  // next iter
        default:
            errx(EXIT_FAILURE, "Unknown mid state %d, aborting!", expect_state);
        }

        start_arg = phx_get_relation_argtaint(cur_layer->func_id, start_arg, cur_state);
    }

    return safe;
#undef safe
#undef unsafe
}
#endif

static void *__phx_thread_wrapper(void *arg) {
    void *ret;
    // copy
    struct func_arg pa = *(struct func_arg *)arg;
    free(arg);

    __phx_instrument_init_thread();
    pthread_cleanup_push(__phx_instrument_thread_cleanup, NULL);

    ret = pa.start_routine(pa.arg);

    pthread_cleanup_pop(1);

    return ret;
}
